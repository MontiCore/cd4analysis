/* (c) https://github.com/MontiCore/monticore */

import de.monticore.MontiTransExec
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
  id "maven-publish" // Only used to publish the trafos - everything else is published in the root project
  id "de.monticore.generator-withtr" version "$mc_version" // MontiCore Plugin with TR support
}

archivesBaseName = "cd4analysis"

def var_path = "de.monticore"
if (hasProperty('bootstrap')) {
  group = "de.monticore.lang.bs"
  var_path = "de.monticore.bs"
} else {
  group = "de.monticore.lang"
}

def withDSTLGen = ("true").equals(getProperty('genTR'))
def withTagGen = ("true").equals(getProperty('genTagging'))

ext {
  grammar_classifier = "grammars"
  grammarDir = "src/main/grammars"
  grammarOutDir = "$buildDir/generated-sources/monticore/sourcecode"
  trGrammarOutDir = "$buildDir/generated-sources/monticore-tr/sourcecode"
  taggingOutDir = "$buildDir/generated-sources/monticore-tag/sourcecode"
  testGrammarDir = "src/test/grammars"
  testGrammarOutDir = "$buildDir/generated-test-sources/monticore/trafo-sourcecode"
}


sourceSets {
  main {
  }
  test {
    if (withDSTLGen) {
      java.srcDirs += ["src/test/javatrafo/", testGrammarOutDir]
    }
    if (withTagGen) {
      java.srcDirs += ["src/test/javatagging/"]
    }
  }
  // The following is required as we still publish a Feature-variant (with usingSourceSet(grammarsForVariant))
  grammarsForVariant {
    java.srcDirs = []
    resources {
      // DO not include the grammars out dir here (with the TR grammars - those are published separately)
      srcDirs([grammarDir])
      include "**/*.mc4"
      include "**/*.mlc"
    }
    grammars.srcDirs = []
  }
  trafo {
  }
  tagging {
    java.srcDirs = [taggingOutDir]
    grammars.srcDirs = [] // Tagging MCGenTasks are manually created below
  }
}

configurations {
  trafoImplementation.extendsFrom implementation
  trafoCompileOnly.extendsFrom compileOnly
  taggingImplementation.extendsFrom implementation
  taggingCompileOnly.extendsFrom compileOnly

  // Note: This should not be necessary, but due to cd4as gradle setup we have to add an unique identifier to each outgoing grammar config
  grammarSymbolOutElements {
    attributes.attribute(Attribute.of('monticore.generator.sourceset', String), "main")
  }
}

dependencies {
  grammar("$var_path:monticore-grammar:$mc_version")
  implementation "$var_path:monticore-grammar:$mc_version" // Dependency for the compat publication - otherwise not necessary
  implementation "$var_path:class2mc:${project.properties['mc_version']}"
  implementation "com.fasterxml.jackson.core:jackson-databind:$jackson_version"
  implementation "org.apache.commons:commons-lang3:$commons_lang_version"

  testImplementation "org.freemarker:freemarker:$freemarker_version"
  testImplementation "org.junit.jupiter:junit-jupiter-api:$junit_version"
  testImplementation "org.junit.jupiter:junit-jupiter-params:$junit_version"
  testImplementation "org.junit.vintage:junit-vintage-engine:$junit_version"
  testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junit_version"
  testImplementation ("de.monticore:monticore-runtime:${project.properties['mc_version']}") capabilities {
    requireCapability("de.monticore:monticore-runtime-tests")
  }
  testImplementation "org.mockito:mockito-core:$mockito_version"
  testImplementation group: 'com.google.code.findbugs', name: 'jsr305', version: findbugs_version

  //dependencies for trafo
  if (withDSTLGen) {
    trafoGrammar "de.monticore:monticore-grammar-trafo:$mc_version"

    testImplementation(sourceSets.trafo.output.classesDirs)
    testImplementation "de.monticore:monticore-grammar-trafo:$mc_version"
  }
  //dependencies for tagging
  if (withTagGen) {
    taggingGrammar "de.monticore:monticore-grammar:$mc_version" // Tagging Grammars are packed with the main grammar dependency
    implementation "de.monticore:monticore-grammar-tagging:$mc_version"

    testImplementation(sourceSets.tagging.output.classesDirs)
    testImplementation "de.monticore:monticore-grammar-tagging:$mc_version"
  }

}


if (withTagGen) {
  // Explicitly configure tagging
  var generateTagDefGrammars = tasks.register('generateTagDefGrammars', MCGenTask) {
    // Make sure we use the output of the generate task
    // (this ensures, that the inputs are not evaluated too early, resulting in this task being skipped)
    grammar.setFrom(tasks.named("generateMCGrammars", MCGenTask).get().getTagDefOutput().matching {
      exclude(['**/de/monticore/tagging/*', '**/Grammar_WithConcepts*'])
    })
    outputDir = file taggingOutDir
    genTag = true
    modelPath.from(file grammarOutDir)
    dependsOn("generateMCGrammars")


    if (findProperty("ci") != null) {
      script = "de/monticore/monticore_noreports.groovy"
    }
    symbolPathConfiguration.from(configurations.named("taggingGrammarSymbolDependencies"))
  }
  compileTaggingJava.dependsOn(generateTagDefGrammars)
  processGrammarsForVariantResources.dependsOn(generateTagDefGrammars)
  var generateTagSchemaGrammars = tasks.register("generateTagSchemaGrammars", MCGenTask) {
    // Make sure we use the output of the generate task
    // (this ensures, that the inputs are not evaluated too early, resulting in this task being skipped)
    grammar.setFrom(tasks.named("generateMCGrammars", MCGenTask).get().getTagSchemaOutput().matching {
      exclude(['**/de/monticore/tagging/*', '**/de/monticore/grammar/*'])
    })
    outputDir = file taggingOutDir
    modelPath.from(file grammarOutDir)
    dependsOn("generateMCGrammars")
    if (findProperty("ci") != null) {
      script = "de/monticore/monticore_noreports.groovy"
    }
    symbolPathConfiguration.from(configurations.named("taggingGrammarSymbolDependencies"))
  }
  compileTaggingJava.dependsOn(generateTagSchemaGrammars)
  processGrammarsForVariantResources.dependsOn(generateTagSchemaGrammars)

  dependencies {
    // use compileOnly as the tagging- and trafo-artifact are only an extension to the default artifact
    taggingCompileOnly project(path)
  }
}

tasks.register('generateTestTrafos') {}
if (withDSTLGen) {
  fileTree(dir: "$projectDir/src/test/transformations", include: '**/**.mtr').each {
    def g = it
    def taskname = "generateTestTrafo${it.getName().substring(0, it.getName().lastIndexOf('.'))}"
    tasks.register(taskname, MontiTransExec.class) {
      // Note: This task is not cacheable
      dependsOn(tasks.generateTestMCGrammars)
      getClassPath().setFrom(sourceSets.trafo.runtimeClasspath)
      TFGenTool = 'de.monticore.tr.CD4CodeTFGenTool'
      input = file(g)
      outputDir = file(testGrammarOutDir)
    }
    generateTestTrafos.dependsOn(taskname)
  }
}


compileTestJava {
  dependsOn generateTestTrafos
}

tasks.withType(JavaCompile) {
  options.encoding = "UTF-8"
  options.deprecation false
  options.warnings = false
  options.headerOutputDirectory.convention(null)
}

tasks.withType(Test) {
  // this won't work with setting the mills, as they can interleave and break thigs
  // maxParallelForks = Runtime.runtime.availableProcessors() ?: 1
}

tasks.withType(Test) {
  useJUnitPlatform()
  testLogging {
    // controls whether test output is shown
    showExceptions true
    showCauses true
    showStackTraces true
    exceptionFormat TestExceptionFormat.FULL
    info {
      events TestLogEvent.FAILED,
        TestLogEvent.PASSED,
        TestLogEvent.SKIPPED,
        TestLogEvent.STANDARD_OUT
    }
  }
  afterTest { desc, result ->
    logger.lifecycle "${desc.className} > ${desc.name} ${result.resultType}"
  }
  afterSuite { desc, result ->
    if (!desc.parent) { // will match the outermost suite
      def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
      def startItem = '|  ', endItem = '  |'
      logger.lifecycle startItem + output + endItem
    }
  }
  reports {
    html.required = false
  }
}

// build javadoc jar in addition
task javadocJar(type: Jar) {
  from javadoc
  archiveClassifier = "javadoc"
}
// generated java doc contains errors, disable for now
javadoc.failOnError(false)

// build test sources jar in addition
task testSourcesJar(type: Jar) {
  from sourceSets.test.output + sourceSets.test.allSource
  archiveClassifier = "testSources"
}


// build tagging in addition
var taggingJar = tasks.register('taggingJar', Jar) {
  from sourceSets.tagging.output
  archiveAppendix = "tagging"
  tasks.assemble.dependsOn it
}
// build tagging sources in addition
var taggingSourcesJar = tasks.register('taggingSourcesJar', Jar) {
  from sourceSets.tagging.allSource
  archiveClassifier = "tagging-sources"
}
// Tagging grammars are included in the main jar (and are deprecated)

tasks.withType(Jar) {
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

task testReport(type: TestReport) {
  destinationDirectory = file("$buildDir/reports/allTests")
  // Include the results from the 'test' task
  testResults.from(tasks.withType(Test))
}
java {
//  withJavadocJar()
  withSourcesJar()
  // Publish a feature-variant for compatibility - DEPRECATED
  registerFeature('grammars') {
    usingSourceSet(sourceSets.grammarsForVariant)
  }
}

// Because tagging is not properly published as a source set we instead add the tag definitions to the main grammar jars
["grammarsJar", "grammarsForVariantJar"].forEach { taskname ->
  // We have to add it to both the "compability grammarsForVariant", as well as the grammarsJar publication
  tasks.named(taskname, org.gradle.jvm.tasks.Jar) {
    from(tasks.generateMCGrammars.outputDir) {
      include "**/*TagDefinition.mc4", "**/*TagSchema.mc4"
    }
    includeEmptyDirs = false
  }
}

jar {
  archiveBaseName = 'cd4analysis'
  archiveClassifier = ""
}

sourcesJar.dependsOn tasks.generateMCGrammars

jar.dependsOn grammarsJar


tasks.generateTestMCGrammars.dependsOn(tasks.grammarsForVariantJar)

// Ensure the grammars and GrammarsForVariant jars do not conflict
grammarsForVariantJar {
  archiveClassifier = "grammars-compat"
}

if (withDSTLGen) {
  // Publish the -trafo language
  publishing {
    publications {
      // The adhoc trafo component/its publication requires a default publication
      // We restrict this default publication from being published
      // Instead, the root project performs the publishing
      maven(MavenPublication) {
        groupId = 'doNotUse'
        artifactId = 'DoNotUse'
      }

      "trafo" {
        groupId = "de.monticore.lang"
        artifactId = "cd4analysis-trafo"
      }
    }
  }

  [PublishToMavenRepository, PublishToMavenLocal].forEach {
    tasks.withType(it).configureEach {
      onlyIf { // do not publish the default publication (ony the trafo one)
        publication != publishing.publications.maven
      }
    }
  }
}
