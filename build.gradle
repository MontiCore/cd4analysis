import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

/* (c) https://github.com/MontiCore/monticore */

plugins {
  id "java"
  id "monticore" version "$mc_version" // MontiCore Plugin
  id "maven-publish"
  id "com.github.johnrengelman.shadow" version "6.0.0" apply false
  id "de.set.ecj" version "1.4.1" // Eclipse compiler as it's much faster than javac
  id 'org.unbroken-dome.test-sets' version '4.0.0'
  id "com.github.sherter.google-java-format" version "0.9"    // Task "verifyGoogleJavaFormat" and "googleJavaFormat"
}

def var_path = "de.monticore"
if (hasProperty('bootstrap')) {
  group = "de.monticore.lang.bs"
  var_path = "de.monticore.bs"
} else {
  group = "de.monticore.lang"
}

description = "CD4Analysis"
sourceCompatibility = JavaVersion.VERSION_11
buildDir = file("$projectDir/target")

ext {
  grammar_classifier = "grammars"
  grammarDir = "src/main/grammars"
  grammarOutDir = "$buildDir/generated-sources/monticore/sourcecode"
  testGrammarDir = "src/test/grammars"
  testGrammarOutDir = "$buildDir/generated-test-sources/monticore/sourcecode"
  findbugs_version = "3.0.2"
  guava_version = "31.1-jre"
  antlr_version = "4.7-1"
  plantuml_version = "1.2020.15"
  jackson_version = "2.13.4"
  junit_version = "5.9.0"
  commons_cli_version = "1.5.0"
  commons_lang_version = "3.11"
  jupiter_version = "5.6.0"
  antlr_version = '4.7.1'
  freemarker_version = "2.3.31"
  javaparser_version = "3.14.11"
  mockito_version = "3.11.1"
  logback_version = "1.2.3"
  apache_commons_version = '4.4'
}


googleJavaFormat {
  exclude '**/target/**'
}

verifyGoogleJavaFormat{
  ignoreFailures true
  exclude "**"
}  // do not check format in "build"

task checkfmt(type: com.github.sherter.googlejavaformatgradleplugin.VerifyGoogleJavaFormat) {}

task fmt {
  dependsOn tasks.named("googleJavaFormat")
}


// configure non-standard source sets
def genDir = "$buildDir/generated-sources/monticore/sourcecode"
def testGenDir = "$buildDir/generated-test-sources/monticore/sourcecode"

sourceSets {
  main {
    java.srcDirs += ["$genDir"]
  }
  test {
    java.srcDirs += ["$testGenDir"]
  }
  grammars {
    resources {
      srcDirs([grammarDir, grammarOutDir])
      include "**/*.mc4"
    }
  }
  cd2plantuml {
    java {}
  }
  cddiff {
    java {}
  }
  cddifftest {
    java {}
  }
  cdmerge {
    java {}
  }
  cdmergetest {
    java {}
  }
  cd2smt {
    java {}
  }
  cd2smttest {
    java {}
  }
  tool {
    java {}
  }
  tooltest {
    java {}
  }
}

configurations {
  cd2plantumlImplementation.extendsFrom(implementation)

  cddiffImplementation.extendsFrom(implementation)
  cddifftestImplementation.extendsFrom(testImplementation)
  cddifftestImplementation.extendsFrom(cddiffImplementation)

  cdmergeImplementation.extendsFrom(implementation)
  cdmergetestImplementation.extendsFrom(testImplementation)
  cdmergetestImplementation.extendsFrom(cdmergeImplementation)

  cd2smtImplementation.extendsFrom(cddiffImplementation)
  cd2smttestImplementation.extendsFrom(cd2smtImplementation)
  cd2smttestImplementation.extendsFrom(cddifftestImplementation)

  toolImplementation.extendsFrom(cddiffImplementation)
  toolImplementation.extendsFrom(cdmergeImplementation)
  tooltestImplementation.extendsFrom(toolImplementation)
  tooltestImplementation.extendsFrom(cddifftestImplementation)
  tooltestImplementation.extendsFrom(cdmergetestImplementation)
  grammar
  cli
}

dependencies {
  grammar("$var_path:monticore-grammar:$mc_version") {
    capabilities {
      requireCapability("$var_path:monticore-grammar-grammars")
    }
  }
  implementation "$var_path:monticore-grammar:${project.properties['mc_version']}"
  implementation "$var_path:monticore-runtime:${project.properties['mc_version']}"
  implementation "$var_path:class2mc:${project.properties['mc_version']}"
  implementation "de.se_rwth.commons:se-commons-logging:$commons_version"
  implementation "de.se_rwth.commons:se-commons-utilities:$commons_version"
  implementation "com.google.guava:guava:$guava_version"
  implementation "com.fasterxml.jackson.core:jackson-databind:$jackson_version"
  implementation "commons-cli:commons-cli:$commons_cli_version"
  implementation "org.apache.commons:commons-lang3:$commons_lang_version"
  testImplementation "org.freemarker:freemarker:$freemarker_version"
  testImplementation "org.junit.jupiter:junit-jupiter-api:$junit_version"
  testImplementation "org.junit.jupiter:junit-jupiter-params:$junit_version"
  testImplementation "org.junit.vintage:junit-vintage-engine:$junit_version"
  testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junit_version"
  testImplementation ("de.monticore:monticore-runtime:${project.properties['mc_version']}") capabilities {
    requireCapability("de.monticore:monticore-runtime-tests") }
  testImplementation "org.mockito:mockito-core:$mockito_version"
  testImplementation group: 'com.google.code.findbugs', name: 'jsr305', version: findbugs_version

  // dependencies for cd2plantuml
  cd2plantumlImplementation(sourceSets.main.output.classesDirs)
  cd2plantumlImplementation("net.sourceforge.plantuml:plantuml:$plantuml_version")

  // dependencies for cddiff
  cddiffImplementation("de.monticore.lang:od:$mc_version") {
    exclude group: 'de.monticore.lang', module:'cd4analysis'
  }
  cddiffImplementation "edu.mit.alloy:alloy:6"
  cddiffImplementation(sourceSets.main.output.classesDirs)

  cddifftestImplementation(sourceSets.cddiff.output.classesDirs)
  cddifftestImplementation(sourceSets.test.output.classesDirs)

  // dependencies for cdmerge
  cdmergeImplementation(sourceSets.main.output.classesDirs)

  cdmergetestImplementation(sourceSets.cdmerge.output.classesDirs)
  cdmergetestImplementation(sourceSets.test.output.classesDirs)

  //dependencies for cd2smt
  cd2smtImplementation(sourceSets.cddiff.output.classesDirs)
  cd2smtImplementation 'tools.aqua:z3-turnkey:4.11.2'

  cd2smttestImplementation(sourceSets.cd2smt.output.classesDirs)
  cd2smttestImplementation(sourceSets.cddifftest.output.classesDirs)

  toolImplementation(sourceSets.cd2plantuml.output.classesDirs)
  toolImplementation(sourceSets.cddiff.output.classesDirs)
  toolImplementation(sourceSets.cdmerge.output.classesDirs)
  tooltestImplementation(sourceSets.tool.output.classesDirs)
}

allprojects {
  repositories {
    if (("true").equals(getProperty('useLocalRepo'))) {
      mavenLocal()
    }
    maven {
      credentials.username mavenUser
      credentials.password mavenPassword
      url repo
    }
    mavenCentral()
  }
}

// list of all grammars, needed to have a fix order
def grammarDependencies = [
  CDBasis           : [],
  CDInterfaceAndEnum: ["CDBasis"],
  CDAssociation     : ["CDBasis"],
  CD4Analysis       : ["CDInterfaceAndEnum", "CDAssociation"],
  CD4CodeBasis      : ["CDBasis", "CDInterfaceAndEnum"],
  CD4Code           : ["CD4Analysis", "CD4CodeBasis"],
]

// list of all grammars, needed to have a fix order
def testGrammarDependencies = [
  TestCDBasis           : ["CDBasis"],
  TestCDInterfaceAndEnum: ["CDInterfaceAndEnum"],
  TestCDAssociation     : ["CDAssociation"],
  TestCD4CodeBasis      : ["CD4CodeBasis"],
  TestTypeImporter      : ["CD4Code"],
]

String createGrammarName(String name) {
  "${grammarDir}/de/monticore/${name}.mc4"
}

String createTestGrammarName(String name) {
  "${testGrammarDir}/de/monticore/${name}.mc4"
}

// one task per grammar file
grammarDependencies.each {
  def g = createGrammarName(it.key)
  def grammarName = it.key
  def dependencies = it.value

  task "generateGrammar${grammarName}"(type: MCTask) {
    def dependsOnGrammars = grammarDependencies[grammarName].collect { name -> tasks["generateGrammar${name}"] }
    dependsOn dependsOnGrammars
    templatePath("$projectDir/src/main/grammars")
    def grammarFile = file g
    grammar = grammarFile
    outputDir = file grammarOutDir
    handcodedPath "$projectDir/src/main/java"
    dstlGen = true
    def grammarIncludingPackage = file(grammarDir).toURI().relativize(grammarFile.toURI()).toString()

    def uptoDate = incCheck(grammarIncludingPackage)

    def superGrammarsList = dependencies.collect {
      def grammar = file createGrammarName(it)
      return grammar.toURI()
    }
    superGrammars.from(superGrammarsList)

    outputs.upToDateWhen { uptoDate }
  }
  task "generateTRGrammar${grammarName}"(type: MCTask) {
    def dependsOnTRGrammars = grammarDependencies[grammarName].collect { name -> tasks["generateTRGrammar${name}"] }
    dependsOn dependsOnTRGrammars
    templatePath("$projectDir/src/main/grammars")
    def grammarFile = file(grammarOutDir + "/" + de.monticore.dstlgen.util.DSTLPathUtil.getTRGrammar([file("src/main/grammars").toString()], file (g))) // Replace with getTRFile(file (g)) once the plugin is updated and in the upstream
    grammar = grammarFile
    outputDir = file grammarOutDir
    handcodedPath "$projectDir/src/main/java"
    dstlGen = false // Do NOT generate TR grammars for TR grammars
    def grammarIncludingPackage = file(grammarOutDir).toURI().relativize(grammarFile.toURI()).toString()

    def uptoDate = incCheck(grammarIncludingPackage)

    modelPath(grammarOutDir)
    modelPath(grammarDir)

    outputs.upToDateWhen { uptoDate }
  }
}

// one task per test grammar file
testGrammarDependencies.each {
  def g = createTestGrammarName(it.key)
  def grammarName = it.key
  def dependencies = it.value

  task "generateTestGrammar${grammarName}"(type: MCTask) {
    def dependsOnGrammars = grammarDependencies[grammarName].collect { name -> tasks["generateGrammar${name}"] }
    dependsOn dependsOnGrammars
    templatePath("$projectDir/src/main/grammars")
    def grammarFile = file g
    grammar = file g
    outputDir = file testGrammarOutDir
    handcodedPath "$projectDir/src/test/java"
    def grammarIncludingPackage = file(testGrammarDir).toURI().relativize(grammarFile.toURI()).toString()
    def uptoDate = incCheck(grammarIncludingPackage)

    def superGrammarsList = dependencies.collect {
      def grammar = file createGrammarName(it)
      return grammar.toURI()
    }
    superGrammars.from(superGrammarsList)

    outputs.upToDateWhen { uptoDate }
  }
}

task generateTestTrafos {}
fileTree(dir: "$projectDir/src/test/transformations", include: '**/**.mtr').each {
  def g = it
  def taskname = "generateTestTrafo${it.getName().substring(0, it.getName().lastIndexOf('.'))}"
  task "$taskname"(type: MontiTransExec) {
    getClassPath().setFrom(sourceSets.test.compileClasspath)
    TFGenTool = 'de.monticore.tr.CD4CodeTFGenTool'
    input = file(g)
    outputDir = file(testGrammarOutDir)
  }
  generateTestTrafos.dependsOn("$taskname")
}


task generate {
  dependsOn project.collect { it.tasks.findAll { task -> task.name.startsWith("generateGrammar") } }
}

task generateTR {
  dependsOn project.collect { it.tasks.findAll { task -> task.name.startsWith("generateTRGrammar") } }
}

task generateTest {
  dependsOn project.collect { it.tasks.findAll { task -> task.name.startsWith("generateTestGrammar") } }
}

compileJava {
  dependsOn project.collect { it.tasks.findAll { task -> task.name.startsWith("generateGrammar") } }
  dependsOn project.collect { it.tasks.findAll { task -> task.name.startsWith("generateTRGrammar") } }
}

compileTestJava {
  dependsOn project.collect { it.tasks.withType(MCTask) }
  dependsOn generateTestTrafos
}

task cddifftest(type: Test) {
  description = "Runs CDDiff Tests"
  group = "Verification"
  testClassesDirs = sourceSets.cddifftest.output.classesDirs
  classpath += sourceSets.cddifftest.runtimeClasspath
  shouldRunAfter test
}

task cdmergetest(type: Test) {
    description = "Runs CDMerge Tests"
    group = "Verification"
    testClassesDirs = sourceSets.cdmergetest.output.classesDirs
    classpath += sourceSets.cdmergetest.runtimeClasspath
    shouldRunAfter test
}

task cd2smttest(type: Test) {
    description = "Runs CD2SMT Tests"
    group = "Verification"
    testClassesDirs = sourceSets.cd2smttest.output.classesDirs
    classpath += sourceSets.cd2smttest.runtimeClasspath
    shouldRunAfter test
}


task tooltest(type: Test) {
  description = "Runs Tool Tests"
  group = "Verification"
  testClassesDirs = sourceSets.tooltest.output.classesDirs
  classpath += sourceSets.tooltest.runtimeClasspath
  shouldRunAfter test
}

check.dependsOn cddifftest, cdmergetest, cd2smttest, tooltest

tasks.withType(JavaCompile) {
  options.encoding = "UTF-8"
  options.deprecation false
  options.warnings = false
  options.fork = true
  options.headerOutputDirectory.convention(null)
  options.forkOptions.with {
    executable = 'java'
    jvmArgs = ['-classpath', project.configurations.ecj.asPath, 'org.eclipse.jdt.internal.compiler.batch.Main', '-nowarn', "-Xmx2048m"]
  }
}

tasks.withType(Test) {
  // this won't work with setting the mills, as they can interleave and break thigs
  // maxParallelForks = Runtime.runtime.availableProcessors() ?: 1
}

tasks.withType(Test) {
  useJUnitPlatform()
  testLogging {
    // controls whether test output is shown
    showExceptions true
    showCauses true
    showStackTraces true
    exceptionFormat TestExceptionFormat.FULL
    info {
      events TestLogEvent.FAILED,
        TestLogEvent.PASSED,
        TestLogEvent.SKIPPED,
        TestLogEvent.STANDARD_OUT
    }
  }
  afterTest { desc, result ->
    logger.lifecycle "${desc.className} > ${desc.name} ${result.resultType}"
  }
  afterSuite { desc, result ->
    if (!desc.parent) { // will match the outermost suite
      def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
      def startItem = '|  ', endItem = '  |'
      logger.lifecycle startItem + output + endItem
    }
  }
  reports {
    junitXml.enabled = false
    html.enabled = false
  }
}

// build javadoc jar in addition
task javadocJar(type: Jar) {
  from javadoc
  archiveClassifier = "javadoc"
}
// generated java doc contains errors, disable for now
javadoc.failOnError(false)

// build test sources jar in addition
task testSourcesJar(type: Jar) {
  from sourceSets.test.output + sourceSets.test.allSource
  archiveClassifier = "testSources"
}

// build test sources jar in addition
task cd2plantumlJar(type: Jar) {
  from sourceSets.cd2plantuml.output + sourceSets.cd2plantuml.allSource
  archiveClassifier = "cd2plantuml"
}

// build test sources jar in addition
task cddiffJar(type: Jar) {
  from sourceSets.cddiff.output + sourceSets.cddiff.allSource
  archiveClassifier = "cddiff"
}

// build test sources jar in addition
task cdmergeJar(type: Jar) {
    from sourceSets.cdmerge.output + sourceSets.cdmerge.allSource
    archiveClassifier = "cdmerge"
}

// build test sources jar in addition
task cd2smtJar(type: Jar) {
    from sourceSets.cd2smt.output + sourceSets.cd2smt.allSource
    archiveClassifier = "cd2smt"
}


// build test sources jar in addition
task toolJar(type: Jar) {
  from sourceSets.tool.output + sourceSets.tool.allSource
  archiveClassifier = "tool"
}

task mainJar(type: Jar) {
  from sourceSets.main.output + sourceSets.main.allSource
  archiveClassifier = "main"
}

if(("false").equals(getProperty('publishMain'))) {
  jar.dependsOn cddiffJar, cdmergeJar, cd2smtJar, toolJar
  apply plugin: "com.github.johnrengelman.shadow"
  shadowJar { // all in one jar
    archiveFileName = 'MCCD.jar'
    manifest {
      attributes "Main-Class": "de.monticore.CD4CodeTool"
    }
    from sourceSets.tool.runtimeClasspath
    archiveClassifier = "mc-tool"
  }
  assemble.dependsOn(shadowJar)
}


testSets {
  integrationTest {
    dirName = '01.experiments'
  }
}

//check.dependsOn integrationTest
integrationTest.mustRunAfter test

/*
integrationTest {
    testLogging {
        showStandardStreams = true
    }
    outputs.upToDateWhen { false }
    options.useJunit()
}*/

task testReport(type: TestReport) {
  destinationDir = file("$buildDir/reports/allTests")
  // Include the results from the 'test' task
  reportOn tasks.withType(Test)
}
java {
//  withJavadocJar()
  withSourcesJar()
  registerFeature('grammars') {
    usingSourceSet(sourceSets.grammars)
  }
}

sourcesJar.dependsOn project.collect { it.tasks.withType(MCTask)}

jar.dependsOn grammarsJar


artifacts {
  archives cddiffJar
  archives cdmergeJar
  archives cd2smtJar
  archives toolJar
  archives mainJar
}
// configure deployment
publishing {
  // configure what artifacts to publish
  publications {
    if(("false").equals(getProperty('publishMain'))) {
      mavenJava(MavenPublication) {
        suppressPomMetadataWarningsFor('grammarsApiElements')
        suppressPomMetadataWarningsFor('grammarsRuntimeElements')
        from components.java
        artifact testSourcesJar
        artifact cddiffJar
        artifact cdmergeJar
        artifact cd2smtJar
        artifact toolJar
      }
    }else{
      mavenJava(MavenPublication) {
        suppressPomMetadataWarningsFor('grammarsApiElements')
        suppressPomMetadataWarningsFor('grammarsRuntimeElements')
        from components.java
        artifact mainJar
      }
    }
  }
  repositories.maven {
    credentials.username mavenUser
    credentials.password mavenPassword
    def releasesRepoUrl = "https://nexus.se.rwth-aachen.de/content/repositories/monticore-releases/"
    def snapshotsRepoUrl = "https://nexus.se.rwth-aachen.de/content/repositories/monticore-snapshots/"
    url = version.endsWith("SNAPSHOT") ? snapshotsRepoUrl : releasesRepoUrl
  }
}

task testMain (type:Test) {
  group("verification")
  description("Tests the main sources set and its grammars with the test source set.")
  testClassesDirs = sourceSets.test.output.classesDirs
  classpath = sourceSets.test.runtimeClasspath
}

task buildMain (type:GradleBuild){
  group("build")
  description("Builds only the main source set with its grammars.")
  dependsOn(classes)
  dependsOn(testMain)
}

