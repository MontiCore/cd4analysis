/* (c) https://github.com/MontiCore/monticore */
plugins {
    id "java"
    id "monticore" version "6.2.0" // MontiCore Plugin
    id "maven-publish"
    id "com.github.johnrengelman.shadow" version "6.0.0"
    id "de.set.ecj" version "1.4.1" // Eclipse compiler as it's much faster than javac
    id 'org.unbroken-dome.test-sets' version '3.0.1'
}

group = "de.monticore.lang"
version = "4.1.0-SNAPSHOT"
description = "CD4Analysis"
sourceCompatibility = JavaVersion.VERSION_1_8
buildDir = file("$projectDir/target")

ext {
    grammar_classifier = "grammars"
    grammarDir = "src/main/grammars"
    grammarOutDir = "$buildDir/generated-sources/monticore/sourcecode"
    testGrammarDir = "src/test/grammars"
    testGrammarOutDir = "$buildDir/generated-test-sources/monticore/sourcecode"

    mc_version = "6.2.0"
    commons_version = "1.7.9"
    guava_version = "25.1-jre"
    antlr_version = "4.7-1"
    plantuml_version = "1.2020.15"
    logback_version = "1.2.3"
    junit_version = "4.13"
    commons_cli_version = "1.4"
    commons_lang_version = "3.11"
}

// configure non-standard source sets
sourceSets {
    main {
        java.srcDirs += ["$projectDir/target/generated-sources/monticore/sourcecode"]
    }
    test {
        java.srcDirs += ["$projectDir/target/generated-test-sources/monticore/sourcecode"]
    }
    grammars {
        resources {
            srcDirs(grammarDir)
            include "**/*.mc4"
        }
    }
}

configurations { grammar }

dependencies {
    implementation "de.monticore:monticore-grammar:$mc_version"
    grammar "de.monticore:monticore-grammar:$mc_version"
    grammar "de.monticore:monticore-grammar:$mc_version:$grammar_classifier"
    implementation "de.se_rwth.commons:se-commons-logging:$commons_version"
    implementation "de.se_rwth.commons:se-commons-utilities:$commons_version"
    implementation "com.google.guava:guava:$guava_version"
    implementation "net.sourceforge.plantuml:plantuml:$plantuml_version"
    implementation "ch.qos.logback:logback-classic:$logback_version"
    implementation "commons-cli:commons-cli:$commons_cli_version"
    implementation "org.apache.commons:commons-lang3:$commons_lang_version"
    testImplementation "org.antlr:antlr4-runtime:$antlr_version"
    testImplementation "junit:junit:$junit_version"
    testImplementation "de.monticore:monticore-runtime:$mc_version:tests"
    testImplementation "de.monticore:monticore-runtime:$mc_version"
}

repositories {
    mavenLocal()
    maven {
        credentials.username mavenUser
        credentials.password mavenPassword
        url repo
    }
}

// list of all grammars, needed to have a fix order
def grammarDependencies = [
        CDBasis           : [],
        CDInterfaceAndEnum: ["CDBasis"],
        CDAssociation     : ["CDBasis"],
        CD4Analysis       : ["CDInterfaceAndEnum", "CDAssociation"],
        CD4CodeBasis      : ["CDBasis", "CDInterfaceAndEnum"],
        CD4Code           : ["CD4Analysis", "CD4CodeBasis"],
]

// list of all grammars, needed to have a fix order
def testGrammarDependencies = [
        TestCDBasis           : ["CDBasis"],
        TestCDInterfaceAndEnum: ["CDInterfaceAndEnum"],
        TestCDAssociation     : ["CDAssociation"],
        TestCD4CodeBasis      : ["CD4CodeBasis"],
        TestTypeImporter      : ["CD4Code"],
]

String createGrammarName(String name) {
    "${grammarDir}/de/monticore/${name}.mc4"
}

String createTestGrammarName(String name) {
    "${testGrammarDir}/de/monticore/${name}.mc4"
}

// one task per grammar file
grammarDependencies.each {
    def g = createGrammarName(it.key)
    def grammarName = it.key
    def dependencies = it.value

    task "generateGrammar${grammarName}"(type: MCTask) {
        def dependsOnGrammars = grammarDependencies[grammarName].collect { name -> tasks["generateGrammar${name}"] }
        dependsOn dependsOnGrammars

        def grammarFile = file g
        grammar = grammarFile
        outputDir = file grammarOutDir
        handcodedPath file("$projectDir/src/main/java")
        def grammarIncludingPackage = file(grammarDir).toURI().relativize(grammarFile.toURI()).toString()

        def uptoDate = incCheck(grammarIncludingPackage)

        def superGrammarsList = dependencies.collect {
            def grammar = file createGrammarName(it)
            return grammar.toURI()
        }
        superGrammars.from(superGrammarsList)

        outputs.upToDateWhen { uptoDate }
    }
}

// one task per test grammar file
testGrammarDependencies.each {
    def g = createTestGrammarName(it.key)
    def grammarName = it.key
    def dependencies = it.value

    task "generateTestGrammar${grammarName}"(type: MCTask) {
        def dependsOnGrammars = grammarDependencies[grammarName].collect { name -> tasks["generateGrammar${name}"] }
        dependsOn dependsOnGrammars

        def grammarFile = file g
        grammar = file g
        outputDir = file testGrammarOutDir
        handcodedPath file("$projectDir/src/test/java")
        def grammarIncludingPackage = file(testGrammarDir).toURI().relativize(grammarFile.toURI()).toString()
        def uptoDate = incCheck(grammarIncludingPackage)

        def superGrammarsList = dependencies.collect {
            def grammar = file createGrammarName(it)
            return grammar.toURI()
        }
        superGrammars.from(superGrammarsList)

        outputs.upToDateWhen { uptoDate }
    }
}

task generate {
    dependsOn project.collect { it.tasks.findAll { task -> task.name.startsWith("generateGrammar") } }
}

task generateTest {
    dependsOn project.collect { it.tasks.findAll { task -> task.name.startsWith("generateTestGrammar") } }
}

compileJava {
    dependsOn project.collect { it.tasks.findAll { task -> task.name.startsWith("generateGrammar") } }
}

compileTestJava {
    dependsOn project.collect { it.tasks.withType(MCTask) }
}

// Fixes issue with java plugin in projects without resources
compileTestJava.doFirst { mkdir sourceSets.main.output.resourcesDir }

tasks.withType(JavaCompile) {
    options.encoding = "UTF-8"
    options.deprecation false
    options.warnings = false
    options.fork = true
    options.headerOutputDirectory.convention(null)
}

tasks.withType(Test) {
    maxParallelForks = Runtime.runtime.availableProcessors() ?: 1
}

// build javadoc jar in addition
task javadocJar(type: Jar) {
    from javadoc
    archiveClassifier = "javadoc"
}
// generated java doc contains errors, disable for now
javadoc.failOnError(false)

shadowJar { // all in one jar
    manifest {
        attributes "Main-Class": "de.monticore.cd.cli.CDCLI"
    }
    archiveClassifier = "cli"
    minimize()
}

testSets {
    integrationTest {
        dirName = 'it'
    }
}

//check.dependsOn integrationTest
integrationTest.mustRunAfter test

/*
integrationTest {
    testLogging {
        showStandardStreams = true
    }
    outputs.upToDateWhen { false }
    options.useJunit()
}*/

task testReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/allTests")
    // Include the results from the 'test' task
    reportOn tasks.withType(Test)
}
java {
//  withJavadocJar()
    withSourcesJar()
    registerFeature('grammars') {
        usingSourceSet(sourceSets.grammars)
    }
}

jar.dependsOn grammarsJar

// configure deployment
publishing {
    // configure what artifacts to publish
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }
    repositories.maven {
        credentials.username mavenUser
        credentials.password mavenPassword
        def releasesRepoUrl = "https://nexus.se.rwth-aachen.de/content/repositories/monticore-releases/"
        def snapshotsRepoUrl = "https://nexus.se.rwth-aachen.de/content/repositories/monticore-snapshots/"
        url = version.endsWith("SNAPSHOT") ? snapshotsRepoUrl : releasesRepoUrl
    }
}